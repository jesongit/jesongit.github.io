<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>「笔记」Erlang 学习笔记 | 粥盐籽</title><meta name="author" content="Posase"><meta name="copyright" content="Posase"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="开始 安装：官方下载 scoop install erlang apt install erlang windows 注意环境变量的配置   建议：编码规范 参考书籍：Erlang 趣学指南  函数式编程 不可变的变量：定义了就不能改变 引用透明 没有副作用 多线程不共享状态，不会出现死锁，适合并发 使用递归，没有循环语句(for&#x2F;while 都需要可变状态进行循环)   尾调用和尾递归">
<meta property="og:type" content="article">
<meta property="og:title" content="「笔记」Erlang 学习笔记">
<meta property="og:url" content="https://www.posase.im/posts/a747f4e9/index.html">
<meta property="og:site_name" content="粥盐籽">
<meta property="og:description" content="开始 安装：官方下载 scoop install erlang apt install erlang windows 注意环境变量的配置   建议：编码规范 参考书籍：Erlang 趣学指南  函数式编程 不可变的变量：定义了就不能改变 引用透明 没有副作用 多线程不共享状态，不会出现死锁，适合并发 使用递归，没有循环语句(for&#x2F;while 都需要可变状态进行循环)   尾调用和尾递归">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.posase.im/img/cover.jpg">
<meta property="article:published_time" content="2023-03-25T17:21:24.000Z">
<meta property="article:modified_time" content="2023-12-22T15:47:44.000Z">
<meta property="article:author" content="Posase">
<meta property="article:tag" content="Erlang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.posase.im/img/cover.jpg"><link rel="shortcut icon" href="/img/zyz.png"><link rel="canonical" href="https://www.posase.im/posts/a747f4e9/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//static.cloudflareinsights.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script defer="defer" data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;10457b82ec7e4763b5b11f0250e30c1b&quot;}"></script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"本文最后更新于","messageNext":"天前，其中信息可能已经不够准确，请酌情参考！"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '「笔记」Erlang 学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-22 23:47:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/zyz.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/img/cover.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="粥盐籽"><span class="site-name">粥盐籽</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">「笔记」Erlang 学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-25T17:21:24.000Z" title="发表于 2023-03-26 01:21:24">2023-03-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-22T15:47:44.000Z" title="更新于 2023-12-22 23:47:44">2023-12-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="「笔记」Erlang 学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ul>
<li>安装：<a target="_blank" rel="noopener" href="https://www.erlang.org/downloads">官方下载</a><ul>
<li><code>scoop install erlang</code></li>
<li><code>apt install erlang</code></li>
<li>windows 注意环境变量的配置</li>
</ul>
</li>
<li>建议：<a target="_blank" rel="noopener" href="https://www.erlang.org/eeps">编码规范</a></li>
<li>参考书籍：<code>Erlang</code> 趣学指南</li>
</ul>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><ul>
<li>不可变的变量：定义了就不能改变<ul>
<li>引用透明</li>
<li>没有副作用</li>
<li>多线程不共享状态，不会出现死锁，适合并发</li>
<li>使用递归，没有循环语句(for&#x2F;while 都需要可变状态进行循环)</li>
</ul>
</li>
<li>尾调用和尾递归</li>
<li>高阶函数：参数或返回值为函数的函数，复用粒度更低</li>
<li>模式匹配</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不可变类似学过的数学变量</span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line">x = y + <span class="number">3</span></span><br><span class="line">x = <span class="number">5</span></span><br><span class="line">x = x + <span class="number">1</span> <span class="comment"># ???</span></span><br><span class="line"><span class="number">5</span> = <span class="number">6</span>     <span class="comment"># ???</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 尾递归 累加 1-n 伪代码，Tips: Python 没有尾递归优化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n + add(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">n, <span class="built_in">sum</span></span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> add(n - <span class="number">1</span>, <span class="built_in">sum</span> + n)</span><br></pre></td></tr></table></figure>

<h3 id="其他特点"><a href="#其他特点" class="headerlink" title="其他特点"></a>其他特点</h3><ul>
<li><code>actor</code> 模型，独立进程，无共享，邮箱通信<ul>
<li>进程之间不会影响，每个进程做自己的事情就好了</li>
</ul>
</li>
<li>编译字节码，可以在任何环境运行</li>
<li>可以在不中断的情况下升级代码，热更新</li>
<li>分布式</li>
<li>let it crash !<ul>
<li>强大的伸缩能力，是因为及其轻量的进程</li>
<li>并非不处理错误，监控再用一定的策略处理</li>
<li>监督机制 link&#x2F;monitor，crash 会起新进程</li>
<li>外界的输入，可以预知的错误，不可恢复的上下文(tcp连接)</li>
</ul>
</li>
</ul>
<blockquote>
<p>Erlang 并不是万能的，请根据需求选择合适的工具<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25070432">Let it crash: 因为误解，所以瞎说</a></p>
</blockquote>
<h3 id="Erlang-Shell"><a href="#Erlang-Shell" class="headerlink" title="Erlang Shell"></a>Erlang Shell</h3><p>安装配置好后，在 cmd&#x2F;shell 键入 erl 进入 Erlang Shell</p>
<p>windows 还有 werl.exe 有一个单独的窗口和一下快捷键</p>
<p>内置 Emacs 功能子集 Ctrl-A&#x2F;E (行首&#x2F;尾) 上下切换命令, Tab 补全</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">help</span><span class="params">()</span>.             % 帮助 .表示语句的结束</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">** <span class="title">shell</span> 内置指令 **</span></span><br><span class="line"><span class="function"><span class="title">b</span><span class="params">()</span>                     -- 显示所有定义的变量</span></span><br><span class="line"><span class="function"><span class="title">e</span><span class="params">(N)</span>                    -- 重复第N步操作</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">()</span>                     -- 释放所有变量</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(X)</span>                    -- 释放指定变量</span></span><br><span class="line"><span class="function"><span class="title">h</span><span class="params">()</span>                     -- 历史操作</span></span><br><span class="line"><span class="function"><span class="title">h</span><span class="params">(Mod)</span>                  -- <span class="title">help</span> <span class="title">about</span> <span class="title">module</span></span></span><br><span class="line"><span class="function"><span class="title">h</span><span class="params">(Mod,Func)</span>             -- <span class="title">help</span> <span class="title">about</span> <span class="title">function</span> <span class="title">in</span> <span class="title">module</span></span></span><br><span class="line"><span class="function"><span class="title">h</span><span class="params">(Mod,Func,Arity)</span>       -- <span class="title">help</span> <span class="title">about</span> <span class="title">function</span> <span class="title">with</span> <span class="title">arity</span> <span class="title">in</span> <span class="title">module</span></span></span><br><span class="line"><span class="function"><span class="title">ht</span><span class="params">(Mod)</span>                 -- <span class="title">help</span> <span class="title">about</span> <span class="title">a</span> <span class="title">module&#x27;s</span> <span class="title">types</span></span></span><br><span class="line"><span class="function"><span class="title">ht</span><span class="params">(Mod,Type)</span>            -- <span class="title">help</span> <span class="title">about</span> <span class="title">type</span> <span class="title">in</span> <span class="title">module</span></span></span><br><span class="line"><span class="function"><span class="title">ht</span><span class="params">(Mod,Type,Arity)</span>      -- <span class="title">help</span> <span class="title">about</span> <span class="title">type</span> <span class="title">with</span> <span class="title">arity</span> <span class="title">in</span> <span class="title">module</span></span></span><br><span class="line"><span class="function"><span class="title">hcb</span><span class="params">(Mod)</span>                -- <span class="title">help</span> <span class="title">about</span> <span class="title">a</span> <span class="title">module&#x27;s</span> <span class="title">callbacks</span></span></span><br><span class="line"><span class="function"><span class="title">hcb</span><span class="params">(Mod,CB)</span>             -- <span class="title">help</span> <span class="title">about</span> <span class="title">callback</span> <span class="title">in</span> <span class="title">module</span></span></span><br><span class="line"><span class="function"><span class="title">hcb</span><span class="params">(Mod,CB,Arity)</span>       -- <span class="title">help</span> <span class="title">about</span> <span class="title">callback</span> <span class="title">with</span> <span class="title">arity</span> <span class="title">in</span> <span class="title">module</span></span></span><br><span class="line"><span class="function"><span class="title">history</span><span class="params">(N)</span>              -- 设置保存之前操作命令的条数  </span></span><br><span class="line"><span class="function"><span class="title">results</span><span class="params">(N)</span>              -- 设置保存之前操作结果的条数  </span></span><br><span class="line"><span class="function"><span class="title">catch_exception</span><span class="params">(Bool)</span>   -- 设置的执行过程中的异常处理  </span></span><br><span class="line"><span class="function"><span class="title">v</span><span class="params">(N)</span>                    -- 使用某次查询的值 &lt;N&gt;  </span></span><br><span class="line"><span class="function"><span class="title">rd</span><span class="params">(R,D)</span>                 -- 定义一个 <span class="title">record</span>  </span></span><br><span class="line"><span class="function"><span class="title">rf</span><span class="params">()</span>                    -- 移除所有 <span class="title">record</span>  </span></span><br><span class="line"><span class="function"><span class="title">rf</span><span class="params">(R)</span>                   -- 移除某个 <span class="title">record</span>  </span></span><br><span class="line"><span class="function"><span class="title">rl</span><span class="params">()</span>                    -- 显示所有 <span class="title">record</span>  </span></span><br><span class="line"><span class="function"><span class="title">rl</span><span class="params">(R)</span>                   -- 显示某个 <span class="title">record</span> 信息  </span></span><br><span class="line"><span class="function"><span class="title">rp</span><span class="params">(Term)</span>                -- 显示某个元组的所有内容  </span></span><br><span class="line"><span class="function"><span class="title">rr</span><span class="params">(File)</span>                -- 从一个文件或模块读取 <span class="title">record</span> 定义</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">** <span class="title">c</span> 模块命令 **  </span></span><br><span class="line"><span class="function"><span class="title">bt</span><span class="params">(Pid)</span>    -- 显示一个进程的栈回溯  </span></span><br><span class="line"><span class="function"><span class="title">c</span><span class="params">(File)</span>    -- 编译及重新加载模块  </span></span><br><span class="line"><span class="function"><span class="title">cd</span><span class="params">(Dir)</span>    -- 改变工作目录  </span></span><br><span class="line"><span class="function"><span class="title">flush</span><span class="params">()</span>    -- 刷新信箱（以便<span class="title">shell</span>接收信息）  </span></span><br><span class="line"><span class="function"><span class="title">help</span><span class="params">()</span>     -- 帮助信息  </span></span><br><span class="line"><span class="function"><span class="title">i</span><span class="params">()</span>        -- 显示系统信息  </span></span><br><span class="line"><span class="function"><span class="title">ni</span><span class="params">()</span>       -- 和 <span class="title">i</span><span class="params">()</span> 一样显示系统信息，还包括网络节点的系统信息  </span></span><br><span class="line"><span class="function"><span class="title">i</span><span class="params">(X,Y,Z)</span>   -- 通过 <span class="title">pid</span> &lt;X,Y,Z&gt; 获取某个进程的信息  </span></span><br><span class="line"><span class="function"><span class="title">l</span><span class="params">(Module)</span>  -- 加载或重新加载模块  </span></span><br><span class="line"><span class="function"><span class="title">lc</span><span class="params">([File])</span> -- 编译一个列表的 E<span class="title">rlang</span> 模块  </span></span><br><span class="line"><span class="function"><span class="title">ls</span><span class="params">()</span>       -- 显示当前工作目录下的文件列表  </span></span><br><span class="line"><span class="function"><span class="title">ls</span><span class="params">(Dir)</span>    -- 显示某个目录下的文件列表  </span></span><br><span class="line"><span class="function"><span class="title">m</span><span class="params">()</span>        -- 显示已加载进系统的模块  </span></span><br><span class="line"><span class="function"><span class="title">m</span><span class="params">(Mod)</span>     -- 显示某个模块信息  </span></span><br><span class="line"><span class="function"><span class="title">memory</span><span class="params">()</span>   -- 显示内存分配信息  </span></span><br><span class="line"><span class="function"><span class="title">memory</span><span class="params">(T)</span>  -- 显示某项内存分配信息 &lt;T&gt;  </span></span><br><span class="line"><span class="function"><span class="title">nc</span><span class="params">(File)</span>   -- 在所有节点编译及加载模块  </span></span><br><span class="line"><span class="function"><span class="title">nl</span><span class="params">(Module)</span> -- 在所有节点重新加载模块  </span></span><br><span class="line"><span class="function"><span class="title">pid</span><span class="params">(X,Y,Z)</span> -- 通过 <span class="title">pid</span> &lt;X,Y,Z&gt; 获取某个进程 <span class="title">pid</span>  </span></span><br><span class="line"><span class="function"><span class="title">pwd</span><span class="params">()</span>      -- 显示当前工作目录  </span></span><br><span class="line"><span class="function"><span class="title">q</span><span class="params">()</span>        -- 关闭 <span class="title">erlang</span> <span class="title">shell</span>  </span></span><br><span class="line"><span class="function"><span class="title">regs</span><span class="params">()</span>     -- 显示注册过的进程信息  </span></span><br><span class="line"><span class="function"><span class="title">nregs</span><span class="params">()</span>    -- 和 <span class="title">regs</span><span class="params">()</span> 一样显示注册过的进程信息，还包括网络节点的进程信息  </span></span><br><span class="line"><span class="function"><span class="title">xm</span><span class="params">(M)</span>      -- 查找某个模块未定义的函数，未使用的函数，已弃用的函数  </span></span><br><span class="line"><span class="function"><span class="title">y</span><span class="params">(File)</span>    -- 编译 Y<span class="title">ecc</span> 文件<span class="params">(.yrl)</span>  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">** <span class="title">i</span> 模块命令  **  </span></span><br><span class="line"><span class="function"><span class="title">ih</span><span class="params">()</span>       -- 显示 <span class="title">i</span> 模块的帮助信息</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">%% C<span class="title">trl</span> + G 可以切换 <span class="title">job</span>，再按 <span class="title">h</span> 显示下面的内容</span></span><br><span class="line"><span class="function">U<span class="title">ser</span> <span class="title">switch</span> <span class="title">command</span></span></span><br><span class="line"><span class="function">--&gt;</span> h</span><br><span class="line">c [nn]              - 连接到一个 job</span><br><span class="line">i [nn]              - 中断 job 运行</span><br><span class="line">k [nn]              - 终止 job</span><br><span class="line">j                   - 查看所有 job</span><br><span class="line">s [shell]           - 启动一个本地 shell</span><br><span class="line">r [node [shell]]    - 启动一个远程 shell</span><br><span class="line">q                   - 退出 shell</span><br><span class="line">? | h               - 显示帮助</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以直接<code>Ctrl-C</code>两次快速退出<code>Shell</code></p>
</blockquote>
<blockquote>
<p>键入<code>io:format(&quot;hello world~n&quot;).</code>，回车会打印一个<code>hello world</code></p>
</blockquote>
<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 百分号后面是注释</span></span><br><span class="line"><span class="comment">%% 数值 erlang 并不关心输入的数字类型，都可以进行运算</span></span><br><span class="line"><span class="number">2</span> + <span class="number">15</span>.     <span class="comment">% 17</span></span><br><span class="line"><span class="number">5</span> / <span class="number">2</span>.      <span class="comment">% 2.5</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">div</span> <span class="number">2</span>.    <span class="comment">% 2 整除</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rem</span> <span class="number">2</span>.    <span class="comment">% 1 余数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% Base#Value  Base进制的数</span></span><br><span class="line"><span class="number">2#101010</span>.   <span class="comment">% 42</span></span><br><span class="line"><span class="number">8#0677</span>.     <span class="comment">% 447</span></span><br><span class="line"><span class="number">16#AE</span>.      <span class="comment">% 174</span></span><br></pre></td></tr></table></figure>

<h3 id="不变的变量"><a href="#不变的变量" class="headerlink" title="不变的变量"></a>不变的变量</h3><p><code>Erlang</code> 变量名由字母，下划线，数字组成，以大写字母或下划线开头</p>
<p>只能赋值一次(绑定&#x2F;定义更合适)，下划线开头仅用于不关心值的情况</p>
<p>除了第一次绑定变量，其他情况都视为<code>模式匹配</code></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">One = <span class="number">1</span>.</span><br><span class="line">Two = One + One.</span><br><span class="line">One = One. <span class="comment">% 没问题</span></span><br><span class="line">One = Two. <span class="comment">% 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="原子"><a href="#原子" class="headerlink" title="原子"></a>原子</h3><p>原子是以小写字母开头，或者用单引号包裹的的字面量<br>所见即所得，一个原子的值就是他本身，一个不可变的常量<br>使用原子的速度非常快，但是原子表不会被回收，所以不要动态创建原子<br>同时有一些保留字<code>after</code> 、<code>and</code> 、<code>andalso</code> 、<code>band</code> 、<code>begin</code> 、<code>bnot</code> 、<code>bor</code> 、<code>bsl</code> 、<code>bsr</code> 、 <code>bxor</code> 、<code>case</code> 、<code>catch</code> 、<code>cond</code> 、<code>div</code> 、<code>end</code> 、<code>fun</code> 、<code>if</code> 、<code>let</code> 、<code>not</code> 、<code>of</code> 、<code>or</code> 、<code>orelse</code> 、<code>query</code> 、<code>receive</code> 、<code>rem</code> 、<code>try</code> 、<code>when</code> 和 <code>xor</code></p>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 布尔操作符</span></span><br><span class="line"><span class="literal">true</span> <span class="keyword">and</span> <span class="literal">false</span>.     <span class="comment">% false 两边都会求值</span></span><br><span class="line"><span class="literal">true</span> <span class="keyword">andalso</span> <span class="literal">false</span>. <span class="comment">% false 短路运算，如果左边为 false 直接得到 false</span></span><br><span class="line"><span class="literal">true</span> or <span class="literal">false</span>.      <span class="comment">% true 两边都会求值</span></span><br><span class="line"><span class="literal">true</span> <span class="keyword">orelse</span> <span class="literal">false</span>.  <span class="comment">% true 短路运算</span></span><br><span class="line"><span class="keyword">not</span> <span class="literal">true</span>.           <span class="comment">% false</span></span><br><span class="line"><span class="literal">true</span> <span class="keyword">xor</span> <span class="literal">false</span>      <span class="comment">% true 亦或</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 位操作符</span></span><br><span class="line"><span class="keyword">bsl</span>                 <span class="comment">% 左移</span></span><br><span class="line">bsr                 <span class="comment">% 右移</span></span><br><span class="line"><span class="keyword">band</span>                <span class="comment">% 按位和</span></span><br><span class="line"><span class="keyword">bor</span>                 <span class="comment">% 按位与</span></span><br><span class="line"><span class="keyword">bxor</span>                <span class="comment">% 按位异或</span></span><br><span class="line"><span class="keyword">bnot</span>                <span class="comment">% 按位非</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 其他操作符 建议始终使用 =:= 和 =/=</span></span><br><span class="line"><span class="number">1.0</span> =:= <span class="number">1</span>.          <span class="comment">% true 全等，会比较类型和值</span></span><br><span class="line"><span class="number">1.0</span> == <span class="number">1</span>.           <span class="comment">% true 相等，仅比较值</span></span><br><span class="line"><span class="number">1.0</span> =/= <span class="number">1</span>.          <span class="comment">% false</span></span><br><span class="line"><span class="number">1.0</span> == <span class="number">1</span>.           <span class="comment">% true</span></span><br><span class="line"><span class="comment">%% 另外还有 &gt;、&lt;、&gt;=、=&lt;(注意这个)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>数据类型直接大小顺序：<code>number</code> &lt; <code>atom</code> &lt; <code>reference</code> &lt; <code>fun</code> &lt; <code>port</code> &lt; <code>pid</code> &lt; <code>tuple</code> &lt; <code>list</code> &lt; <code>bit string</code></p>
</blockquote>
<h3 id="元组和列表"><a href="#元组和列表" class="headerlink" title="元组和列表"></a>元组和列表</h3><p>列表是以链表的形式存储，所以当连接两个列表时候，需要遍历左边的列表找到尾节点连接</p>
<p>元组是使用连续的内存，可以很方便的访问元素，但是更新或者添加元素会导致重新创建并生成新的元组</p>
<p>但是新元组中的元素不会每次重新创建，会共享未更改的内容以节省内存，元组和列表中的元素也会共享。也只有不可变的特性才可以实现</p>
<p>在计算结构中元素个数时候，如果是常量时间内就能得到结果的则命名为<code>size</code>，如果是线性时间内得到结果的命名为<code>length</code>。例如：<code>tuple_size</code>, <code>byte_size</code>; <code>length</code>, <code>String.length</code></p>
<blockquote>
<p>参考自<a href="./%E3%80%8C%E7%AC%94%E8%AE%B0%E3%80%8DElixir-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md">Elixir 笔记</a></p>
</blockquote>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 其中的值可以是任意类型</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>&#125;. <span class="comment">% 元组</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]. <span class="comment">% 列表</span></span><br><span class="line"></span><br><span class="line">Pos = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;.</span><br><span class="line">&#123;X, Y&#125; = Pos.           <span class="comment">% 模式匹配取值</span></span><br><span class="line">&#123;_, Y&#125; = Pos.           <span class="comment">% _ 可以匹配任何值，忽略不关心的值</span></span><br><span class="line"><span class="function"><span class="title">element</span><span class="params">(<span class="number">1</span>, Pos)</span>.        % 1 获取指定位置值</span></span><br><span class="line"><span class="function"><span class="title">setelement</span><span class="params">(<span class="number">1</span>, Pos, <span class="number">2</span>)</span>.  % &#123;2, 2&#125; 改变指定位置值并返回新的元组</span></span><br></pre></td></tr></table></figure>

<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>].</span><br><span class="line">B = [<span class="number">1</span>, <span class="number">2</span>].</span><br><span class="line">List = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].</span><br><span class="line">[<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>].           <span class="comment">% &quot;abc&quot; 字符串，只有存在非字符的值才会打印原列表</span></span><br><span class="line">A ++ B.                 <span class="comment">% [1, 1, 2] 注意是右结合，从右往左算 </span></span><br><span class="line">B -- A.                 <span class="comment">% [2]. 小列表在前，性能更高</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 取头元素和尾列表</span></span><br><span class="line"><span class="function"><span class="title">hd</span><span class="params">(List)</span>.               % 1</span></span><br><span class="line"><span class="function"><span class="title">tl</span><span class="params">(List)</span>.               % [2, 3]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">%% 通常使用 | 可以非常简便的取元素或者构造列表</span></span><br><span class="line"><span class="function">[H | T] = L<span class="title">ist</span>.         % H = 1, T = [2, 3]</span></span><br><span class="line"><span class="function">L = [1, 2 | L<span class="title">ist</span>].      % [1, 2, 1, 2, 3]</span></span><br><span class="line"><span class="function">L = [1 | [2 | L<span class="title">ist</span>]].   % [1, 2, 1, 2, 3]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">[X * 2 || X &lt;- L<span class="title">ist</span>].               % [2, 4, 6] 列表推导式</span></span><br><span class="line"><span class="function">[X * 2 || X &lt;- L<span class="title">ist</span>, X <span class="title">rem</span> 2 == 0]. % [4] 带条件的推导式，这里过滤后只有留下了偶数</span></span><br><span class="line"><span class="function">[X + Y || X &lt;- [1, 2], Y - [3, 4]]. % [4, 5, 5, 6] 可以使用多个推导式</span></span><br><span class="line"><span class="function">[X || &#123;X, 1&#125; &lt;- [&#123;2, 1&#125;, &#123;3, 2&#125;]].  % [2] 可以通过模式匹配来过滤结果</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips：<code>hd/1</code>这种称为内建函数(<code>BIF</code>函数)，通常一些常用操作，为了使操作性能更高使用其他语音实现</p>
</blockquote>
<blockquote>
<p><code>|</code>操作符称为<code>cons</code>操作符（构造器），左边可以是任意个元素，右边必须是一个列表，构造后形成一个新的列表</p>
</blockquote>
<h3 id="二进制数据"><a href="#二进制数据" class="headerlink" title="二进制数据"></a>二进制数据</h3><p><code>Erlang</code>中使用<code>&lt;&lt;&gt;&gt;</code>来表示二进制数据, 区段之间用<code>,</code>隔开</p>
<p>当然需要一点基础前置知识：<code>1Byte(字节) = 8bit(位)</code>，以及一些进制转换的知识</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Bin = &lt;&lt;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&gt;&gt;.      <span class="comment">% &lt;&lt;&quot;abc&quot;&gt;&gt; 这里 abc 的 ASCII 码分别是 97, 98, 99，所以是&quot;abc&quot;</span></span><br><span class="line">&lt;&lt;<span class="number">200</span>, <span class="number">210</span>, <span class="number">220</span>, <span class="number">0</span>&gt;&gt;.      <span class="comment">% 无法识别为正常的字符, 这里就会原样输出了</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">%% 上面简单的演示中，每个区段的数字都占用了`8`位的空间，当然也可以手动指定位数</span></span><br><span class="line">&lt;&lt;<span class="number">1</span>:<span class="number">16</span>, <span class="number">0</span>:<span class="number">16</span>&gt;&gt;.            <span class="comment">% &lt;&lt;0, 1, 0, 0&gt;&gt; 这时候1会占2字节，不够会补零</span></span><br><span class="line">&lt;&lt;(<span class="number">16#F09A29</span>):<span class="number">24</span>&gt;&gt;.        <span class="comment">%  &lt;&lt;240, 154, 41&gt;&gt; 这里24位会占3个字节 0xf0(240), 0x9a(154), 0x29(41)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 同样的，也可以通过模式匹配方便的取到想要的值</span></span><br><span class="line">&lt;&lt;X, Y:<span class="number">16</span>&gt;&gt; = &lt;&lt;(<span class="number">16#F09A29</span>):<span class="number">24</span>&gt;&gt;.   <span class="comment">% X = 240, Y = 39465(0x9a29)</span></span><br><span class="line">&lt;&lt;X, Rest/binary&gt;&gt; &lt;&lt;<span class="number">1</span>, <span class="number">2</span>&gt;&gt;.        <span class="comment">% 假如只想取第一个字节，可以直接使用这种写法匹配后面所有的值</span></span><br></pre></td></tr></table></figure>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p><code>&lt;&lt;Value:Size/Type, Rest/binary&gt;&gt;</code>.   % 二进制数据可以通过该格式来描述</p>
<p>其中<code>Size 默认是</code>8<code>位, </code>Type<code>默认是</code>integer&#96;</p>
<p><code>Type</code>可以由多个类型组成，使用<code>-</code>分割，可能包含下面多个</p>
<ul>
<li>类型包括<code>integer</code>(默认)、<code>float</code>、<code>binary</code>(<code>bytes</code>)、<code>bitstring</code>(<code>bits</code>)、<code>utf8</code>、<code>utf16</code>、<code>utf32</code></li>
<li>符号类型包括<code>signed</code>、<code>unsigned</code>(只有类型是<code>integer</code>才有意义)</li>
<li>字节序包括<code>big</code>(默认)、<code>little</code>、<code>native</code>(只有当类型是数字时才有意义)</li>
<li>单位：<code>unit:Integer</code>的形式，表示区段大小(1 ~ 256)<ul>
<li>对于<code>integer</code>，<code>floag</code>，<code>bitstring</code>来说默认都是 1</li>
<li>对于<code>binary</code>来说默认是 8，<code>utfx</code>无需定义</li>
<li><code>Size * 单位</code> &#x3D; 区段所占的位数<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 用不同字节序表示数字 72, native 是根据 CPU 使用的字节序来自动选择</span></span><br><span class="line">&lt;&lt;<span class="number">72</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&gt;&gt;.        <span class="comment">% 小字节序 </span></span><br><span class="line">&lt;&lt;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">72</span>&gt;&gt;.        <span class="comment">% 大字节序</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>尽管<code>Erlang</code>可以通过匹配来很方便的处理二进制数据，但是<code>Erlang</code>历来不擅长处理数值密集型计算操作，但是对于不需要数值计算的应用处理非常快，构建软实时应用会是非常好的选择</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="二进制字符串"><a href="#二进制字符串" class="headerlink" title="二进制字符串"></a>二进制字符串</h4><p><code>&lt;&lt;&quot;this is abinary string&quot;&gt;&gt;</code> 这就是二进制字符串</p>
<p>二进制字符串对比前面的列表字符串在空间是上更加高效</p>
<p>列表通过链表实现的，而二进制字符串则类似元组是一整块内存</p>
<p>当然缺点是模式匹配会操作方法会比列表麻烦一些</p>
<p>通常当所存储的文本无需频繁操作或者空间效率是个实际问题时，才会使用二进制字符串</p>
<blockquote>
<p>尽管二进制字符串非常轻量，但是不要用来标记数据。{&lt;&lt;”jack”&gt;&gt;, 1}。在涉及比较操作时候就会在线性时间内比较整个字符串，{jack, 1} 使用原子则能在常量时间完成。同样，尽管原子更轻量，但是除了比较，原子无法进行分割、正则其他任何操作</p>
</blockquote>
<h4 id="二进制推导式"><a href="#二进制推导式" class="headerlink" title="二进制推导式"></a>二进制推导式</h4><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 与列表推导式几乎一模一样，看到这里也知道为什么 =&lt; 才是小于等于了吧</span></span><br><span class="line">&lt;&lt; &lt;&lt;X&gt;&gt; || &lt;&lt;X&gt;&gt; &lt;= &lt;&lt;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;, X <span class="keyword">rem</span> <span class="number">2</span> == <span class="number">0</span>&gt;&gt;.   <span class="comment">% &lt;&lt;2&gt;&gt;</span></span><br><span class="line">[ X || &lt;&lt;X&gt;&gt; &lt;= &lt;&lt;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;, X <span class="keyword">rem</span> <span class="number">2</span> == <span class="number">0</span>].         <span class="comment">% [2]</span></span><br><span class="line">&lt;&lt; &lt;&lt;X&gt;&gt; || X &lt;- [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;&gt;.                       <span class="comment">% &lt;&lt;1, 2, 3&gt;&gt;</span></span><br><span class="line"><span class="comment">%% 注意默认情况下，会认为放进来的是 8 位无符号整数</span></span><br><span class="line">&lt;&lt; &lt;&lt;X/binary&gt;&gt; || X &lt;- [&lt;&lt;<span class="number">1</span>&gt;&gt;, &lt;&lt;<span class="number">2</span>&gt;&gt;, &lt;&lt;<span class="number">3</span>&gt;&gt;] &gt;&gt;.   <span class="comment">% 如果不是则要自己指定类型</span></span><br></pre></td></tr></table></figure>

<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块是具有名字的文件，同时包含一组函数。</p>
<p>通常使用<code>Module:Function(Args)</code>的方式调用函数</p>
<blockquote>
<p>前面使用的<code>hd/1</code>、<code>element/2</code>都是<code>erlang</code>模块下的函数，会自动引入所以无需<code>Module</code></p>
</blockquote>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%% 一般文件头的概况性注释使用三个百分号</span></span><br><span class="line"><span class="comment">%%% 文件名: test.erl</span></span><br><span class="line"><span class="keyword">-module</span><span class="params">(test)</span>.                  <span class="comment">% 定义一个模块</span></span><br><span class="line"><span class="keyword">-import</span><span class="params">(lists, [sum/<span class="number">1</span>, seq/<span class="number">2</span>])</span>. <span class="comment">% 引入一个模块的函数</span></span><br><span class="line"><span class="keyword">-author</span><span class="params">(posase)</span>.                <span class="comment">% 作者，可忽略</span></span><br><span class="line"><span class="comment">%% 引入后就可以直接调用了，但是当两个模块有重名函数就会有问题，所以不建议使用</span></span><br><span class="line"><span class="comment">%% 另外会降低代码的可读性，无法直接看出函数是内部函数还是外部函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 单独一行的注释使用两个百分号，同时与代码使用相同的缩进</span></span><br><span class="line"><span class="comment">%% 下面的行内注释使用一个百分号</span></span><br><span class="line"><span class="keyword">-export</span><span class="params">([       <span class="comment">% 定义一些导出的函数 即本模块的接口</span></span></span><br><span class="line"><span class="params">    add/<span class="number">2</span>,      <span class="comment">% 函数名为 add，需要两个参数</span></span></span><br><span class="line"><span class="params">    test/<span class="number">0</span></span></span><br><span class="line"><span class="params">])</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-define</span><span class="params">(ONE,        <span class="number">1</span>)</span>.     <span class="comment">% 宏定义 使用格式：?ONE</span></span><br><span class="line"><span class="keyword">-define</span><span class="params">(HORE,       <span class="number">60</span>*<span class="number">60</span>)</span>. <span class="comment">% 一小时的秒数</span></span><br><span class="line"><span class="keyword">-define</span><span class="params">(sub(A, B),  A - B)</span>. <span class="comment">% 定义一个函数也是可以的</span></span><br><span class="line"><span class="comment">%% 另外有一些预定义的宏：?MODULE(模块名)、?FILE(文件名)、?LINE(行号)</span></span><br><span class="line"><span class="comment">%% 还可以根据条件来定义宏 例子如下</span></span><br><span class="line"><span class="comment">%% 下面这个就只有存在 TEST 这个时候宏时候，调用debug/1才会打印</span></span><br><span class="line"><span class="keyword">-ifdef</span><span class="params">(TEST)</span>.</span><br><span class="line"><span class="keyword">-define</span><span class="params">(debug(S), io:format(<span class="string">&quot;debug: ~s~n&quot;</span>, [S]))</span>.</span><br><span class="line"><span class="keyword">-else</span>.</span><br><span class="line"><span class="keyword">-define</span><span class="params">(debug(S), ok)</span>.</span><br><span class="line"><span class="keyword">-endif</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 函数例子</span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(A, B)</span> -&gt;</span>    <span class="comment">% 实现add函数</span></span><br><span class="line">    A + B.      <span class="comment">% 函数最后一行的结果会被返回</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(A, B, C)</span> -&gt;</span></span><br><span class="line">    A + B + C.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">test</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    <span class="comment">%% 这里的 sum/1 和 seq/2 都是 lsits 模块的函数</span></span><br><span class="line">    &#123;add(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), sum(seq(<span class="number">1</span>, <span class="number">2</span>))&#125;.</span><br></pre></td></tr></table></figure>

<h3 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h3><ul>
<li>在<code>cmd</code>中可以直接使用<code>erlc test.erl</code>编译模块</li>
<li>在<code>Shell</code>中可以使用<code>compile:file(test).</code>&#x2F;<code>c(test)</code> 编译模块</li>
<li>如果不是同级目录，可以在<code>Shell</code>中使用 <code>cd(&quot;xxxk&quot;)</code> 进入模块文件目录<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 编译完成后可以来调用一下我们写的函数，add/3因为没用导出无法调用</span></span><br><span class="line">test:add(<span class="number">1</span>, <span class="number">1</span>).     <span class="comment">% 2</span></span><br><span class="line">test:test().        <span class="comment">% &#123;3, 3&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="不使用-Shell-运行程序"><a href="#不使用-Shell-运行程序" class="headerlink" title="不使用 Shell 运行程序"></a>不使用 Shell 运行程序</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% test.erl</span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(Args)</span> -&gt;</span></span><br><span class="line">    <span class="comment">%% todo</span></span><br><span class="line">    io:format(<span class="string">&quot;hello world. ~p~n&quot;</span>, [Args]),</span><br><span class="line">    erlang:halt(). <span class="comment">% 这个调用回关闭 Erlang VM</span></span><br><span class="line"><span class="comment">%% 终端中</span></span><br><span class="line">erlc test.erl</span><br><span class="line">erl -noshell -run test main <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="escript"><a href="#escript" class="headerlink" title="escript"></a><code>escript</code></h4><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env escript</span><br><span class="line"><span class="comment">%% -*- erlang -*-</span></span><br><span class="line"><span class="comment">%% ! -pa &#x27;ebin/&#x27; [&lt;em&gt; 其他参数 &lt;/em&gt;]</span></span><br><span class="line"><span class="comment">%% test.erl</span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(Args)</span> -&gt;</span></span><br><span class="line">    <span class="comment">%% todo</span></span><br><span class="line">    ok.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以使用 <code>./test.erl</code>或<code>escript test.erl</code> 像脚本一样运行</p>
</blockquote>
<h4 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h4><ul>
<li><code>debug_info</code>: 一些工具需要使用这个选项来工作，建议一直开启</li>
<li><code>&#123;outdir, Dir&#125;</code>: 指定<code>.beam</code>文件存放路径，默认当前目录</li>
<li><code>export_all</code>: 会将模块所有函数导出，可以在开发中使用，产品严禁使用</li>
<li><code>&#123;d, Macro&#125;/&#123;d, Macro, Value&#125;</code>: 定义一些宏，<code>Value</code>不设置默认是<code>true</code><blockquote>
<p>格式参考: <code>c(test, [debug_info, export_all]).</code></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>模块上也可以指定编译选项，比如：<code>-compile([debug_info]).</code></p>
</blockquote>
<blockquote>
<p>另外使用<code>hipe:c/2</code>或<code>c(Mod, [native]).</code>会让程序运行更快<br>因为是直接编译成本地码，无法跨平台，通常不建议使用</p>
</blockquote>
<h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>可以通过<code>Mod:module_info/0</code>或<code>Mod:module_info/1</code>来查看一个模块的元数据</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 比如前面举例的文件 test:module_info().</span></span><br><span class="line">[&#123;module,test&#125;,</span><br><span class="line"> &#123;exports,[&#123;add,<span class="number">2</span>&#125;,&#123;test,<span class="number">0</span>&#125;,&#123;module_info,<span class="number">0</span>&#125;,&#123;module_info,<span class="number">1</span>&#125;]&#125;,</span><br><span class="line"> &#123;attributes,[&#123;vsn,[<span class="number">248293221308944576795513279798718263657</span>]&#125;,</span><br><span class="line">              &#123;author,[posase]&#125;]&#125;,</span><br><span class="line"> &#123;compile,[&#123;version,<span class="string">&quot;8.2.4&quot;</span>&#125;,</span><br><span class="line">           &#123;options,[]&#125;,</span><br><span class="line">           &#123;source,<span class="string">&quot;d:/Project/hexo/test.erl&quot;</span>&#125;]&#125;,</span><br><span class="line"> &#123;md5,&lt;&lt;<span class="number">186</span>,<span class="number">203</span>,<span class="number">136</span>,<span class="number">245</span>,<span class="number">38</span>,<span class="number">249</span>,<span class="number">61</span>,<span class="number">45</span>,<span class="number">112</span>,<span class="number">172</span>,<span class="number">137</span>,<span class="number">19</span>,<span class="number">180</span>,</span><br><span class="line">        <span class="number">136</span>,<span class="number">113</span>,<span class="number">105</span>&gt;&gt;&#125;]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>vsn</code> 通常用在代码热加载的区分不同版本</p>
</blockquote>
<h3 id="环形依赖"><a href="#环形依赖" class="headerlink" title="环形依赖"></a>环形依赖</h3><p>一定要避免环形依赖，如果模块<code>A</code>调用了模块<code>B</code>，那么模块<code>B</code>就不应该调用模块<code>A</code></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在<code>Erlang</code>中可以通过模式匹配来实现函数的重载</p>
<p>每一个函数声明称为一个函数子句，必须用<code>;</code>隔开，最后一个以<code>.</code>结尾</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% io:format/2是打印函数，这里就不过多介绍</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a, A)</span> -&gt;</span> <span class="comment">% 第二个参数会自动绑定到 A</span></span><br><span class="line">    io:format(<span class="string">&quot;a: ~p~n&quot;</span>, [A]);  <span class="comment">% 中间用分号隔开</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(b, B)</span> -&gt;</span> <span class="comment">% 第二个参数会自动绑定到 B</span></span><br><span class="line">    io:format(<span class="string">&quot;b: ~p~n&quot;</span>, [B]);</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(&#123;c, C&#125;, D)</span> -&gt;</span> <span class="comment">% 元组等也是可以匹配的</span></span><br><span class="line">    io:format(<span class="string">&quot;~p: ~p~n&quot;</span>, [C, D]).</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 当然，一个变量仍然只能绑定一次，比如下面函数可以判断两个数是否相等</span></span><br><span class="line"><span class="function"><span class="title">same</span><span class="params">(X, X)</span> -&gt;</span></span><br><span class="line">    <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="title">same</span><span class="params">(_, _)</span> -&gt;</span></span><br><span class="line">    <span class="literal">false</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 常用来过滤或验证指定结构</span></span><br><span class="line"><span class="function"><span class="title">print_date</span><span class="params">(&#123;&#123;Y, M, D&#125;, &#123;H, Min, S&#125;&#125;)</span> -&gt;</span></span><br><span class="line">    io:format(<span class="string">&quot;~p-~p-~p ~p:~p:~p~n&quot;</span>, [Y, M, D, H, Min, S]);</span><br><span class="line"><span class="function"><span class="title">print_date</span><span class="params">(_)</span> -&gt;</span></span><br><span class="line">    ok.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 还可以实现尾递归, 列表求和</span></span><br><span class="line"><span class="function"><span class="title">sum</span><span class="params">([], Sum)</span> -&gt;</span></span><br><span class="line">    Sum;</span><br><span class="line"><span class="function"><span class="title">sum</span><span class="params">([H | T], Sum)</span> -&gt;</span></span><br><span class="line">    sum(T, Sum + H).</span><br></pre></td></tr></table></figure>

<h3 id="卫语句"><a href="#卫语句" class="headerlink" title="卫语句"></a>卫语句</h3><p><strong>卫语句</strong> 是附加在函数头的语句，让模式匹配更具表达力</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 假设功能是判断一个整数否处于 0 ~ 3 之间，通过前面学习的可以得到</span></span><br><span class="line"><span class="function"><span class="title">valid</span><span class="params">(<span class="number">1</span>)</span> -&gt;</span> <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="title">valid</span><span class="params">(<span class="number">2</span>)</span> -&gt;</span> <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="title">valid</span><span class="params">(_)</span> -&gt;</span> <span class="literal">false</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 使用卫语句可以表示为</span></span><br><span class="line"><span class="function"><span class="title">valid</span><span class="params">(N)</span> <span class="title">when</span> N &gt; 0, N &lt; 3 -&gt;</span> <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="title">valid</span><span class="params">(_)</span> -&gt;</span> <span class="literal">false</span>.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>逻辑运算符和算术顺算符包括<code>BIF</code>函数都可以使用，除了用户自定义函数</p>
</blockquote>
<blockquote>
<p>在卫表达式中，<code>,</code>和<code>and</code>类似；<code>;</code>和<code>or</code>类似</p>
</blockquote>
<h4 id="一些区别"><a href="#一些区别" class="headerlink" title="一些区别"></a>一些区别</h4><ul>
<li>前者卫语句中的报错会忽略，例如: <code>A; B</code> 中<code>A</code>报错<code>B</code>为真任然可以匹配成功</li>
<li>前者无法嵌套使用，后者可以嵌套：<code>(A and B) or C</code></li>
</ul>
<h3 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a><code>if</code>表达式</h3><p><code>Erlang</code>中的<code>if</code>语句又称卫模式，从名字不难看出和卫语句其实很类似</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> </span><br><span class="line">    A == <span class="number">1</span> -&gt; <span class="comment">% 类似卫语句的判断条件</span></span><br><span class="line">        <span class="number">1</span>;</span><br><span class="line">    A == <span class="number">2</span> -&gt;</span><br><span class="line">        <span class="number">2</span>;</span><br><span class="line">    <span class="literal">true</span> -&gt; </span><br><span class="line">        <span class="number">3</span></span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Erlang 中的表达式一定有返回值，所以需要一个<code>true</code>保证匹配成功</p>
</blockquote>
<h3 id="case-of-表达式"><a href="#case-of-表达式" class="headerlink" title="case ... of 表达式"></a><code>case ... of</code> 表达式</h3><p><code>case ... of</code> 更像一个完整的函数，可以进行<strong>模式匹配</strong>和使用<strong>卫语句</strong></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 假设 &#123;Name, Num&#125; 表示一个人的信息</span></span><br><span class="line"><span class="keyword">case</span> Info <span class="keyword">of</span></span><br><span class="line">    &#123;jack, <span class="number">1</span>&#125; -&gt;</span><br><span class="line">        <span class="string">&quot;is_jack&quot;</span>;</span><br><span class="line">    &#123;tom, <span class="number">2</span>&#125; -&gt;</span><br><span class="line">        <span class="string">&quot;is_tom&quot;</span>;</span><br><span class="line">    &#123;Atom, N&#125; <span class="keyword">when</span> is_atom(Atom), is_integer(N) -&gt;</span><br><span class="line">        <span class="comment">%% is_atom/1, is_integer/1 请看下一节介绍</span></span><br><span class="line">        <span class="string">&quot;is_people&quot;</span>;</span><br><span class="line">    _ -&gt;</span><br><span class="line">        <span class="string">&quot;is_who&quot;</span></span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数、<code>if</code>、<code>case ... of</code> 是使用选择可以基于个人习惯，只要代码保持整洁即可</p>
</blockquote>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul>
<li><code>Erlang</code>是<strong>动态类型语言</strong>，只在运行时候检查类型<ul>
<li>得益于基础理念，组件不应该影响整个系统，意料之外的错误也不会导致系统停止</li>
<li><strong>动态类型</strong>也是实现代码热加载最简便的方法</li>
</ul>
</li>
<li>同时<code>Eralng</code>也是<strong>强类型语言</strong>, 不会进行隐式的类型转换</li>
</ul>
<blockquote>
<p>可以使用<code>TypeA_to_TypeB</code>类似的函数来进行函数转换</p>
</blockquote>
<blockquote>
<p>可以使用<code>is_Type</code>类似函数称为类型检测<code>BIF</code></p>
</blockquote>
<blockquote>
<p>更多<code>BIF</code>函数，详情可在文档或代码中查看</p>
</blockquote>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>函数式编程中通常没用<code>for</code>&#x2F;<code>while</code>之类的循环。相反都是使用<strong>递归</strong>实现</p>
<p> <strong>递归算法</strong>是通过重复将问题分解为同类的子问题而解决问题的方法，在编程中通过函数的自调用实现<br> <figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 比如一个斐波那契数列</span></span><br><span class="line"><span class="function"><span class="title">fac</span><span class="params">(<span class="number">0</span>)</span> -&gt;</span> <span class="number">1</span>;               <span class="comment">% 递归需要一个结束的出口</span></span><br><span class="line"><span class="function"><span class="title">fac</span><span class="params">(N)</span> -&gt;</span> N * fac(N - <span class="number">1</span>).  <span class="comment">% 其他都需要通过调用自己实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 又比如计算列表长度</span></span><br><span class="line"><span class="function"><span class="title">len</span><span class="params">([])</span> -&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="title">len</span><span class="params">([_ | Rest])</span> -&gt;</span> <span class="number">1</span> + len(Rest).</span><br></pre></td></tr></table></figure></p>
<h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p> 首先来分析一下前面正常递归的样子<br> <figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">len</span><span class="params">([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span> = 1 + <span class="title">len</span><span class="params">([<span class="number">2</span>, <span class="number">3</span>])</span> </span></span><br><span class="line"><span class="function">             = 1 + 1 + <span class="title">len</span><span class="params">([<span class="number">3</span>])</span> </span></span><br><span class="line"><span class="function">             = 1 + 1 + 1 + <span class="title">len</span><span class="params">([])</span></span></span><br><span class="line"><span class="function">             = 1 + 1 + 1 + 0</span></span><br><span class="line"><span class="function">             = 1 + 1 + 1</span></span><br><span class="line"><span class="function">             = 1 + 2</span></span><br><span class="line"><span class="function">             = 3</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>因为每一步都依赖下一步的返回，所以即使<code>1+1+1+0</code>，仍然需要一个一个返回相加</p>
</blockquote>
<p>如果加一个参数记录当前的结果，传入后面的递归中，其实就不需要再返回处理了<br>不仅是返回的问题，依赖下一步导致每一步操作都要记录，会占用更多的内存</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 使用尾递归实现计算列表长度</span></span><br><span class="line"><span class="function"><span class="title">len</span><span class="params">([], Len)</span> -&gt;</span> Len;</span><br><span class="line"><span class="function"><span class="title">len</span><span class="params">([_ | Rest], Len)</span> -&gt;</span> len(Rest, Len + <span class="number">1</span>).</span><br></pre></td></tr></table></figure>
<blockquote>
<p>尾递归不依赖下一步的返回，也就不需要留着当前占用，实际就只会占一次调用的空间</p>
</blockquote>
<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 高阶函数 </span></span><br><span class="line"><span class="comment">%% erlang 中可以直接使用 Mod:Fun/Airty 来绑定一个函数</span></span><br><span class="line"><span class="comment">%% 比如下面例子，文件名 test.erl</span></span><br><span class="line"><span class="keyword">-module</span><span class="params">(test)</span>.</span><br><span class="line"><span class="keyword">-compile</span><span class="params">(export_all)</span>.</span><br><span class="line"><span class="function"><span class="title">one</span><span class="params">()</span> -&gt;</span> <span class="number">1</span>.</span><br><span class="line"><span class="function"><span class="title">two</span><span class="params">()</span> -&gt;</span> <span class="number">2</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 这里就需要传进来两个函数，结果是他们的返回值的和</span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(X, Y)</span> -&gt;</span> X() + Y().</span><br><span class="line"></span><br><span class="line"><span class="comment">%% shell中调用</span></span><br><span class="line">test:add(test:one/<span class="number">1</span>, test:two/<span class="number">1</span>).</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 匿名函数</span></span><br><span class="line">F = <span class="keyword">fun</span>() -&gt; a <span class="keyword">end</span>. <span class="comment">% #Fun&lt;erl_eval.xx.xxx&gt;</span></span><br><span class="line">F().                <span class="comment">% a</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h3><p><strong>作用域</strong>顾名思义就是变量可以使用的范围。与继承有点类似，函数可以使用函数外定义的，匿名函数可以使用函数内定义的，反过来则不行</p>
<p><strong>闭包</strong>是将函数内部和函数外部连接起来的桥梁，当匿名函数，作用域和可携带变量的能力组合在一起就是闭包</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 举个例子</span></span><br><span class="line"><span class="function"><span class="title">base</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    A = <span class="number">1</span>,</span><br><span class="line">    <span class="keyword">fun</span>(B) -&gt; A + B.</span><br><span class="line"></span><br><span class="line">F = base(). <span class="comment">% #Fun&lt;...&gt; 返回的是一个匿名函数</span></span><br><span class="line">F(<span class="number">1</span>).       <span class="comment">% 2 通过改子函数使用了 base() 中的A，称其为闭包</span></span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="异常错误"><a href="#异常错误" class="headerlink" title="异常错误"></a>异常错误</h3><ul>
<li>编译期错误，通常是一些语法错误</li>
<li>逻辑错误，测试是最好的防御手段</li>
<li>运行时错误<ol>
<li>函数&#x2F;<code>case</code>&#x2F;<code>if</code>子句错误</li>
<li>匹配错误(一般为函数已经绑定)</li>
<li>参数错误</li>
<li>未定义错误</li>
<li>计算错误（除0，非数值计算）</li>
<li>系统限制错误（进程太多，原子太多等）</li>
</ol>
</li>
</ul>
<h3 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h3><p>包括<code>error</code>、<code>exit</code>、<code>throw</code>，前两个会导致进程之间退出</p>
<p>当期望处理某个可能发生的异常，可以使用<code>throw</code>抛出，同时并不会导致进程退出</p>
<p>在大量函数调用，深度递归中，可以将<code>throw</code>当成返回使用，直接在顶部函数进行捕获，根据抛出信息再进行处理</p>
<blockquote>
<p><code>error</code>和<code>exit</code>的区别是，在捕获的了情况下，<code>error</code>会有更多的调用栈信息</p>
</blockquote>
<h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> F1() <span class="keyword">of</span> <span class="comment">% 捕获 F1() 调用的错误</span></span><br><span class="line">    _ -&gt; ok <span class="comment">% 正常返回的情况</span></span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">    throw: Throw -&gt; Throw;  <span class="comment">% throw 异常</span></span><br><span class="line">    error: Error -&gt; Error;  <span class="comment">% error 异常</span></span><br><span class="line">    exit: Exit -&gt; Exit      <span class="comment">% exit 异常</span></span><br><span class="line"><span class="keyword">after</span>                       <span class="comment">% after 非必须</span></span><br><span class="line">    F2()                    <span class="comment">% 始终会执行 F2()</span></span><br><span class="line"><span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 当有多个语句的时候可以使用</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    <span class="comment">%% todo 这里可以执行多个语句</span></span><br><span class="line">    ok</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">    throw: Throw -&gt; Throw</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>被保护部分因为需要捕获异常，是无法进行尾调用优化的；<br>有<code>after</code>的情况下，即使在<code>of</code>和<code>catch</code>的非保护部分仍然无法尾调用优化</p>
</blockquote>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 甚至可以直接使用 catch 捕获异常 catch/1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">catch</span> F() <span class="keyword">of</span></span><br><span class="line">    &#123;ok, Data&#125; -&gt; Data;                     <span class="comment">% 正常的情况</span></span><br><span class="line">    Throw <span class="keyword">when</span> is_atom(Throw) -&gt; Throw;     <span class="comment">% throw</span></span><br><span class="line">    &#123;&#x27;EXIT&#x27;, &#123;Reason, Stack&#125;&#125; -&gt; Reason;    <span class="comment">% error</span></span><br><span class="line">    &#123;&#x27;EXIT&#x27;, Reason&#125; -&gt;                     <span class="comment">% exit</span></span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>catch/</code>的写法虽然简单，但是也会有一些问题，无法判断是正常的返回还是异常</p>
</blockquote>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><p>其实<strong>记录</strong>就是一个元组，只是第一个元素是标记</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-record</span><span class="params">(node, &#123; <span class="comment">% 定义一个记录，这里是一个节点</span></span></span><br><span class="line"><span class="params">    value = <span class="number">0</span>,  <span class="comment">% 节点值</span></span></span><br><span class="line"><span class="params">    next        <span class="comment">% 下一个节点</span></span></span><br><span class="line"><span class="params">&#125;)</span>.</span><br><span class="line"></span><br><span class="line">Next = #node&#123;value = <span class="number">2</span>, next = nil&#125;.    <span class="comment">% 创建节点</span></span><br><span class="line">Node = #node&#123;value = <span class="number">1</span>, next = Next&#125;.</span><br><span class="line">Val = Node#node.value.                  <span class="comment">% 读取</span></span><br><span class="line">Node1 = Node#node&#123;value = <span class="number">3</span>&#125;.           <span class="comment">% 更新</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Shell</code>中可以使用<code>rr/1</code>导入记录，<code>rd/2</code>定义记录，<code>rf/0</code>删除记录，<code>rl/0</code>展示记录</p>
</blockquote>
<h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><p>如果一个记录很多模块使用，可以使用<strong>头文件</strong>共享记录定义，头文件以<code>.hrl</code>结尾</p>
<p>同时注意使用到的模块需要引入头文件，比如：<code>-include(&quot;reocrd.hrl&quot;).</code></p>
<blockquote>
<p>当然尽量避免不同功能的模块直接直接访问记录，可以提高代码的<strong>可读性</strong>和<strong>可维护性</strong></p>
</blockquote>
<h3 id="键值存储"><a href="#键值存储" class="headerlink" title="键值存储"></a>键值存储</h3><ol>
<li>属性列表：处理<strong>小数据量</strong>，使用很少，比较局限</li>
<li>有序字典(orddict): 处理<strong>小数据量</strong>，为避免顺序错误，应该只使用其提供的接口</li>
<li>字典(dict): 处理<strong>大数据量</strong>，接口和<strong>有序字典</strong>完全一致</li>
<li>通用平衡树(gb_trees): 处理<strong>大数据量</strong>，有<strong>智能模式</strong>和简单模式</li>
</ol>
<ul>
<li><strong>简单模式</strong>的操作函数：<code>enter/2</code>、<code>lookup/2</code>、<code>delete/2</code>、<code>delete_any/2</code></li>
<li><strong>智能模式</strong>的操作函数：<code>insert/3</code>、<code>get/2</code>、<code>update/2</code>、<code>delete/2</code></li>
<li><strong>智能模式</strong>是区分了已知键值是否存在的情况，从而不执行无用的检查达到更快的执行速度</li>
</ul>
<p><code>dict</code>和<code>gb_trees</code>使用起来基本差不多，通常字典读取性能更好，其他操作 GB 树更快一些</p>
<p>字典有<code>fold</code>函数，而 GB 树只有<code>next/1</code>来得到后面的值，意味着只能自己写递归函数遍历</p>
<p>GB 树保留了元素的顺序，有<code>smallest/1</code>和<code>largesst/1</code>快速获取最大&#x2F;小元素</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ol>
<li><code>ordsets</code>: <strong>有序</strong>集合，适用小集合，最慢但是最容易理解<ul>
<li><code>new/0</code>、<code>is_element/2</code>、<code>add_element/2</code>、<code>del_element/2</code>、<code>union/1</code>、<code>intersection/1</code></li>
</ul>
</li>
<li><code>sets</code>: 与<code>dict</code>类似，可以处理更大规模的数据，擅长读密集处理</li>
<li><code>gb_sets</code>: 底层就是一颗<code>gb_trees</code>，同样拥有<strong>智能模式</strong>和简单模式**，特性也类似</li>
<li><code>sofs</code>: 集合的集合，使用有序列表实现，实现数学意义上的集合，二不仅仅是唯一元素时候恨有用</li>
</ol>
<blockquote>
<p><code>sets</code>和<code>gb_sets</code>的选择类似<code>dict</code>和<code>gb_trees</code>，但是注意如果需要使用<code>=:=</code>，则<code>sets</code>是唯一选择</p>
</blockquote>
<h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><p><code>digraph</code>和<code>digraph utils</code>，前者实现了构造和修改，后者实现了遍历、检测等功能</p>
<blockquote>
<p>有需要的时候再深入了解也不是为一个好选择，文档中也非常容易找到相关内容</p>
</blockquote>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p><code>queue</code>: <code>new/0</code>、<code>in/2</code>、<code>out/1</code>、<code>len/1</code>等</p>
<blockquote>
<p>使用两个列表实现的<strong>双端队列</strong></p>
</blockquote>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>并发指在<code>VM</code>中存在多个独立进程，但是并不要求其同时运行</p>
<blockquote>
<p>并行则是多个进程存在的情况下同时运行</p>
</blockquote>
<h3 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h3><p>让进程保持<strong>轻量</strong>是实现伸缩性必需的能力，也不必像进程池固定进程，可以需要多少使用多少<br><code>Erlang</code>通过进制共享内存，采用<strong>消息传递机制</strong>的方式来实现并发的可靠性，效率低一点但是更安全</p>
<h3 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h3><p>得益于<strong>轻量进程</strong>和<strong>消息传递机制</strong>的设计，当出现某个错误可以重启进程，<br>保证进程继续工作的同时防止错误和坏数据传播。<br><strong>分布式</strong>可以实现硬件故障导致的问题，独立的<strong>消息传递机制</strong>可以让进程在不同计算机的工作方式完全一样。</p>
<blockquote>
<p>进程之间是相互独立的，每个进程只会监听自己的<strong>邮箱</strong>，处理自己的工作，以及向其他进程发消息（尽管他可能并不存在）</p>
</blockquote>
<h3 id="并发实现"><a href="#并发实现" class="headerlink" title="并发实现"></a>并发实现</h3><p><code>Erlang</code>在自己的<code>VM</code>中实现<code>Erlang</code>进程，一个进程进占用几百字节的空间，创建时间仅几微秒</p>
<p><code>VM</code>为每个核启动一个线程<strong>调度器</strong>，调度器中有一个<strong>运行队列</strong>，为其中的每个<code>Erlang</code>进程分一小段时间片。<br>同时虚拟机会自动进行<strong>负载均衡</strong>，当某个队列任务过多时会迁移到其他队列</p>
<h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pid = spawn(<span class="keyword">fun</span>() -&gt; <span class="number">1</span> + <span class="number">1</span> <span class="keyword">end</span>).    <span class="comment">% &lt;x.xx.x&gt; 返回一个进程标识符(pid)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 创建多个进程，观察其是如何运行的</span></span><br><span class="line">F = <span class="keyword">fun</span>(N) -&gt; timer:sleep(<span class="number">10</span>), io:format(<span class="string">&quot;~p~n&quot;</span>, [N]) <span class="keyword">end</span>.</span><br><span class="line">[spawn(F(N)) || N &lt;- lists:seq(<span class="number">1</span>, <span class="number">10</span>)].</span><br><span class="line"><span class="comment">%% 打印的结果可能每次都不一样，谁也无法保证谁先运行，这就是并发</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">self</span><span class="params">()</span>. % 查看当前进程的<span class="title">pid</span></span></span><br><span class="line"><span class="function"><span class="title">exit</span><span class="params">()</span>. % 再次查看就变了，因为进程被重启了</span></span><br></pre></td></tr></table></figure>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">self</span><span class="params">()</span> ! <span class="title">hello</span>. % <span class="title">hello</span> 给自己发一个消息</span></span><br><span class="line"><span class="function">%% 返回值就是自己发的消息，所以也可以同时给多个进程发</span></span><br><span class="line"><span class="function"><span class="title">self</span><span class="params">()</span> ! <span class="title">slef</span><span class="params">()</span> ! <span class="title">hello</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">flush</span><span class="params">()</span>. % 可以查看收到的消息</span></span><br></pre></td></tr></table></figure>

<h3 id="接受消息"><a href="#接受消息" class="headerlink" title="接受消息"></a>接受消息</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">receive</span> <span class="comment">% 使用 receive 可以接受消息，与 case ... of 类似，也可以使用模式匹配和卫语句</span></span><br><span class="line">    Msg -&gt;</span><br><span class="line">        io:format(<span class="string">&quot;receive: ~p~n&quot;</span>, [Msg])</span><br><span class="line"><span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">receive</span></span><br><span class="line">    Msg -&gt;</span><br><span class="line">        ok</span><br><span class="line"><span class="keyword">after</span> <span class="number">10</span> -&gt; <span class="comment">% 超时时间，毫秒</span></span><br><span class="line">    <span class="comment">%% todo 超时没收到消息会执行的代码段</span></span><br><span class="line">    ok</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<h3 id="如何回信？"><a href="#如何回信？" class="headerlink" title="如何回信？"></a>如何回信？</h3><p>显然，只需要我们将自己的进程标识符也发过去，对方也就可以回信了</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">tom</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">        &#123;Pid, Msg&#125; <span class="keyword">when</span> is_pid(Pid) -&gt;</span><br><span class="line">            Pid ! Msg;</span><br><span class="line">        _Msg -&gt;</span><br><span class="line">            ok</span><br><span class="line">    <span class="keyword">end</span>.</span><br><span class="line">TomPid = spawn(tom()).</span><br><span class="line">TomPid ! hello.     <span class="comment">% 发一个hello 同时也会收到一个 hello</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>简简单单几行代码就轻松实现了并发通信，更多的是需要理解并发逻辑在实际应用中如何处理</p>
</blockquote>
<h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%% 一个可以存取的盒子进程</span></span><br><span class="line"><span class="function"><span class="title">module</span><span class="params">(box)</span>.</span></span><br><span class="line"><span class="function">-<span class="title">compile</span><span class="params">(export_all)</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">%% 递归实现一直接受和处理消息</span></span><br><span class="line"><span class="function"><span class="title">box</span><span class="params">(List)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">        &#123;From, &#123;add, Item&#125;&#125; -&gt;</span><br><span class="line">            From ! &#123;self(), ok&#125;,</span><br><span class="line">            box([Item | List]);</span><br><span class="line">        &#123;From, &#123;del, Item&#125;&#125; -&gt;</span><br><span class="line">            <span class="keyword">case</span> lists:member(Item, List) <span class="keyword">of</span></span><br><span class="line">                <span class="literal">true</span> -&gt;</span><br><span class="line">                    From ! &#123;self(), &#123;ok, Item&#125;&#125;,</span><br><span class="line">                    box(lists:delete(Item, List));</span><br><span class="line">                <span class="literal">false</span> -&gt;</span><br><span class="line">                    From ! &#123;self(), not_found&#125;,</span><br><span class="line">                    box(List)</span><br><span class="line">        stop -&gt;</span><br><span class="line">            ok</span><br><span class="line">        _ -&gt;</span><br><span class="line">            <span class="comment">%% 避免无用消息占用邮箱，可以添加日志打印等</span></span><br><span class="line">            box(List)</span><br><span class="line">    <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 为了方便外部调用，隐藏消息的实现逻辑</span></span><br><span class="line">add(BoxPid, Item) -&gt;</span><br><span class="line">    BoxPid ! &#123;self(), &#123;add, Item&#125;&#125;,</span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">        &#123;BoxPid, Msg&#125; -&gt; Msg;   <span class="comment">% 正常返回</span></span><br><span class="line">        <span class="keyword">after</span> <span class="number">1000</span> -&gt; timeout   <span class="comment">% 超时的情况</span></span><br><span class="line">    <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line">del(BoxPid, Item) -&gt;</span><br><span class="line">    BoxPid ! &#123;self(), &#123;del, Item&#125;&#125;,</span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">        &#123;BoxPid, Msg&#125; -&gt; Msg</span><br><span class="line">        <span class="keyword">after</span> <span class="number">1000</span> -&gt; timeout</span><br><span class="line">    <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 启动一个盒子进程</span></span><br><span class="line">start() -&gt;</span><br><span class="line">    spawn(?MODULE, box, [[]]).</span><br></pre></td></tr></table></figure>
<p>在<code>Shell</code>中可以使用<code>box:start().</code>启动盒子进程，使用<code>box:add/2</code>添加物品，<code>box:del/2</code>删除物品</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.posase.im">Posase</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.posase.im/posts/a747f4e9/">https://www.posase.im/posts/a747f4e9/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.posase.im" target="_blank">粥盐籽</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Erlang/">Erlang</a></div><div class="post_share"><div class="social-share" data-image="/img/cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/9630983a/" title="「笔记」Debian 折腾手册"><img class="cover" src="/img/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">「笔记」Debian 折腾手册</div></div></a></div><div class="next-post pull-right"><a href="/posts/efff8d67/" title="「笔记」Git 常用指令"><img class="cover" src="/img/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">「笔记」Git 常用指令</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/8f0b5382/" title="「笔记」Demo 合集"><img class="cover" src="/img/cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-08</div><div class="title">「笔记」Demo 合集</div></div></a></div><div><a href="/posts/389b9679/" title="「笔记」问题集合"><img class="cover" src="/img/cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-08</div><div class="title">「笔记」问题集合</div></div></a></div><div><a href="/posts/8cb8b390/" title="「笔记」Erlang 常用启动参数"><img class="cover" src="/img/cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-23</div><div class="title">「笔记」Erlang 常用启动参数</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/zyz.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Posase</div><div class="author-info__description">Posase</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/jesongit" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:188380780@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B"><span class="toc-number">1.</span> <span class="toc-text">开始</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">函数式编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">其他特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Erlang-Shell"><span class="toc-number">1.3.</span> <span class="toc-text">Erlang Shell</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">数值类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%98%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.</span> <span class="toc-text">不变的变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90"><span class="toc-number">2.2.</span> <span class="toc-text">原子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.3.</span> <span class="toc-text">操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84%E5%92%8C%E5%88%97%E8%A1%A8"><span class="toc-number">2.4.</span> <span class="toc-text">元组和列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">2.5.</span> <span class="toc-text">二进制数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.5.1.</span> <span class="toc-text">格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.5.2.</span> <span class="toc-text">二进制字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-number">2.5.3.</span> <span class="toc-text">二进制推导式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-number">3.</span> <span class="toc-text">模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81"><span class="toc-number">3.1.</span> <span class="toc-text">编译代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8-Shell-%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.2.</span> <span class="toc-text">不使用 Shell 运行程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#escript"><span class="toc-number">3.2.1.</span> <span class="toc-text">escript</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9"><span class="toc-number">3.2.2.</span> <span class="toc-text">编译选项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-number">3.3.</span> <span class="toc-text">元数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E4%BE%9D%E8%B5%96"><span class="toc-number">3.4.</span> <span class="toc-text">环形依赖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%AB%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.1.</span> <span class="toc-text">卫语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.1.</span> <span class="toc-text">一些区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">if表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#case-of-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">case ... of 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.4.</span> <span class="toc-text">类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">5.</span> <span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BE%E9%80%92%E5%BD%92"><span class="toc-number">5.1.</span> <span class="toc-text">尾递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">其他函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85"><span class="toc-number">5.3.</span> <span class="toc-text">作用域和闭包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E9%94%99%E8%AF%AF"><span class="toc-number">6.1.</span> <span class="toc-text">异常错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text">异常类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-number">6.3.</span> <span class="toc-text">处理异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">7.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95"><span class="toc-number">7.1.</span> <span class="toc-text">记录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">7.1.1.</span> <span class="toc-text">头文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8"><span class="toc-number">7.2.</span> <span class="toc-text">键值存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">7.3.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-number">7.4.</span> <span class="toc-text">有向图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">7.5.</span> <span class="toc-text">队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">8.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%B8%E7%BC%A9%E6%80%A7"><span class="toc-number">8.1.</span> <span class="toc-text">伸缩性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E9%94%99"><span class="toc-number">8.2.</span> <span class="toc-text">容错</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.3.</span> <span class="toc-text">并发实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">8.4.</span> <span class="toc-text">创建进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">8.5.</span> <span class="toc-text">发送消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97%E6%B6%88%E6%81%AF"><span class="toc-number">8.6.</span> <span class="toc-text">接受消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9B%9E%E4%BF%A1%EF%BC%9F"><span class="toc-number">8.7.</span> <span class="toc-text">如何回信？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">8.8.</span> <span class="toc-text">一个简单的例子</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/b66e0c08/" title="「笔记」Minecraft 我的世界 Fabric 模组入门"><img src="/img/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「笔记」Minecraft 我的世界 Fabric 模组入门"/></a><div class="content"><a class="title" href="/posts/b66e0c08/" title="「笔记」Minecraft 我的世界 Fabric 模组入门">「笔记」Minecraft 我的世界 Fabric 模组入门</a><time datetime="2024-02-24T12:10:09.000Z" title="发表于 2024-02-24 20:10:09">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/346b1fc8/" title="「教程」Nginx Proxy Manager 的简单使用"><img src="/img/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「教程」Nginx Proxy Manager 的简单使用"/></a><div class="content"><a class="title" href="/posts/346b1fc8/" title="「教程」Nginx Proxy Manager 的简单使用">「教程」Nginx Proxy Manager 的简单使用</a><time datetime="2024-01-29T10:51:52.000Z" title="发表于 2024-01-29 18:51:52">2024-01-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5ec05c2f/" title="「笔记」WSL 相关笔记"><img src="/img/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「笔记」WSL 相关笔记"/></a><div class="content"><a class="title" href="/posts/5ec05c2f/" title="「笔记」WSL 相关笔记">「笔记」WSL 相关笔记</a><time datetime="2023-12-24T13:37:02.000Z" title="发表于 2023-12-24 21:37:02">2023-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8cb8b390/" title="「笔记」Erlang 常用启动参数"><img src="/img/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「笔记」Erlang 常用启动参数"/></a><div class="content"><a class="title" href="/posts/8cb8b390/" title="「笔记」Erlang 常用启动参数">「笔记」Erlang 常用启动参数</a><time datetime="2023-12-23T05:49:04.000Z" title="发表于 2023-12-23 13:49:04">2023-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/da8307a0/" title="「笔记」Elixir 学习笔记"><img src="/img/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「笔记」Elixir 学习笔记"/></a><div class="content"><a class="title" href="/posts/da8307a0/" title="「笔记」Elixir 学习笔记">「笔记」Elixir 学习笔记</a><time datetime="2023-06-27T02:39:53.000Z" title="发表于 2023-06-27 10:39:53">2023-06-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Posase</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'EK48PQHZAW',
    apiKey: 'f04e73c59d5a5578630f8397d958fe13',
    indexName: 'posase',
    container: '#docsearch',
  }, null))


  const searchClickFn = () => {
    document.querySelector('#search-button > .search').addEventListener('click', () => {
      document.querySelector('.DocSearch-Button').click()
    })
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></body></html>